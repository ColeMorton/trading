"""
Execution Template Generator

Provides parameterized execution workflow templates for new strategies.
"""

from typing import Any, Dict, List

from .config_template import StrategyType, TemplateConfig


class ExecutionTemplate:
    """Generates parameterized execution workflow templates."""

    def __init__(self, template_config: TemplateConfig):
        self.config = template_config

    def generate_main_execution_file(self) -> str:
        """Generate the main execution file (1_get_portfolios.py) template."""
        strategy_name = self.config.strategy_name
        class_name = strategy_name.replace("_", "").title()

        template = f'''"""
Portfolio Analysis Module for {class_name} Strategy

This module handles portfolio analysis for the {strategy_name} strategy, supporting both
single ticker and multiple ticker analysis. It includes functionality for parameter
sensitivity analysis and portfolio filtering.

Generated by Strategy Template Generator.
"""

from typing import Any, Dict, List

import polars as pl

from app.strategies.{strategy_name}.exceptions import (
    {class_name}ConfigurationError,
    {class_name}Error,
    {class_name}ExecutionError,
    {class_name}PortfolioError,
)
from app.strategies.{strategy_name}.tools.strategy_execution import execute_strategy
from app.tools.entry_point import run_from_command_line
from app.tools.error_decorators import handle_errors
from app.tools.exceptions import (
    ConfigurationError,
    PortfolioLoadError,
    StrategyProcessingError,
)

# Centralized imports for consistency
from app.tools.logging_context import logging_context
from app.tools.orchestration import PortfolioOrchestrator

# Import allocation utilities
from app.tools.portfolio.allocation import (
    calculate_position_sizes,
    distribute_missing_allocations,
    ensure_allocation_sum_100_percent,
    normalize_allocations,
    validate_allocations,
)

# Use centralized error handling
from app.tools.strategy.error_handling import (
    create_error_handler,
    handle_strategy_error,
    StrategyErrorCode,
    ErrorSeverity,
)

# Import schema detection utilities
from app.tools.portfolio.schema_detection import (
    SchemaVersion,
    detect_schema_version,
    normalize_portfolio_data,
)

# Import stop loss utilities
from app.tools.portfolio.stop_loss import (
    calculate_stop_loss_levels,
    normalize_stop_loss,
    validate_stop_loss,
)

from app.tools.portfolio_results import (
    calculate_breadth_metrics,
    filter_open_trades,
    filter_signal_entries,
    sort_portfolios,
)
from app.tools.project_utils import get_project_root
from app.tools.strategy.types import StrategyConfig as Config
from app.tools.strategy_utils import filter_portfolios_by_signal, get_strategy_types

# Configuration
{self.config.get_default_config_instance()}


def filter_portfolios(
    portfolios: List[Dict[str, Any]], config: Config, log
) -> List[Dict[str, Any]]:
    """Filter portfolios based on configuration.

    Args:
        portfolios: List of portfolio dictionaries
        config: Configuration dictionary
        log: Logging function

    Returns:
        Filtered list of portfolio dictionaries
    """
    # First detect schema version and normalize portfolio data
    schema_version = detect_schema_version(portfolios)
    log(f"Detected schema version: {{schema_version.name}}", "info")

    # Normalize portfolio data to handle Allocation [%] and Stop Loss [%] columns
    normalized_portfolios = normalize_portfolio_data(portfolios, schema_version, log)

    # Process allocation and stop loss values if they exist
    if schema_version == SchemaVersion.EXTENDED:
        # Process allocation values
        validated_portfolios = validate_allocations(normalized_portfolios, log)
        normalized_portfolios = normalize_allocations(validated_portfolios, log)
        distributed_portfolios = distribute_missing_allocations(
            normalized_portfolios, log
        )
        normalized_portfolios = ensure_allocation_sum_100_percent(
            distributed_portfolios, log
        )

        # Calculate position sizes if account value is provided in config
        if "ACCOUNT_VALUE" in config and config["ACCOUNT_VALUE"] > 0:
            account_value = float(config["ACCOUNT_VALUE"])
            normalized_portfolios = calculate_position_sizes(
                normalized_portfolios, account_value, log
            )
            log(
                f"Calculated position sizes based on account value: {{account_value}}",
                "info",
            )

        # Process stop loss values
        validated_stop_loss = validate_stop_loss(normalized_portfolios, log)
        normalized_portfolios = normalize_stop_loss(validated_stop_loss, log)

        # If we have entry prices, calculate stop loss levels
        if "ENTRY_PRICES" in config and config["ENTRY_PRICES"]:
            normalized_portfolios = calculate_stop_loss_levels(
                normalized_portfolios, config["ENTRY_PRICES"], log
            )
            log("Calculated stop loss levels based on entry prices", "info")

    # Filter by signal using the standardized filter_portfolios_by_signal function
    filtered = filter_portfolios_by_signal(normalized_portfolios, config, log)

    # Apply consolidated filtering using PortfolioFilterService
    from app.tools.portfolio.filtering_service import PortfolioFilterService

    filter_service = PortfolioFilterService()
    filtered = filter_service.filter_portfolios_list(filtered, config, log)

    # If we have results and want to display them, use the portfolio_results utilities
    if (
        filtered is not None
        and len(filtered) > 0
        and config.get("DISPLAY_RESULTS", True)
    ):
        # Sort portfolios
        sorted_portfolios = sort_portfolios(
            filtered,
            config.get("SORT_BY", "Total Return [%]"),
            config.get("SORT_ASC", False),
        )

        # Get open trades
        open_trades = filter_open_trades(sorted_portfolios, log)

        # Get signal entries
        signal_entries = filter_signal_entries(sorted_portfolios, open_trades, log)

        # Calculate breadth metrics
        calculate_breadth_metrics(sorted_portfolios, open_trades, signal_entries, log)

        return sorted_portfolios

    return filtered


def execute_all_strategies(config: Config, log) -> List[Dict[str, Any]]:
    """Execute all strategies and collect results.

    Args:
        config: Configuration dictionary
        log: Logging function

    Returns:
        List of portfolio dictionaries

    Raises:
        StrategyProcessingError: If there's an error processing a strategy
    """
    strategy_types = get_strategy_types(config, log)
    log(f"Running strategies in sequence: {{' -> '.join(strategy_types)}}")

    all_portfolios = []

    for strategy_type in strategy_types:
        log(f"Running {{strategy_type}} strategy analysis...")
        strategy_config = {{**config}}
        strategy_config["STRATEGY_TYPE"] = strategy_type

        portfolios = execute_strategy(strategy_config, strategy_type, log)

        # Check if portfolios is not None and not empty
        if portfolios is not None:
            if isinstance(portfolios, pl.DataFrame):
                portfolio_count = len(portfolios)
                if portfolio_count > 0:
                    # Convert to dictionaries and process allocation and stop loss values
                    portfolio_dicts = portfolios.to_dicts()
                    all_portfolios.extend(portfolio_dicts)
            else:
                portfolio_count = len(portfolios)
                if portfolio_count > 0:
                    all_portfolios.extend(portfolios)

            log(f"{{strategy_type}} portfolios: {{portfolio_count}}", "info")
        else:
            log(f"{{strategy_type}} portfolios: 0", "info")

    if not all_portfolios:
        log(
            "No portfolios returned from any strategy. Filtering criteria might be too strict.",
            "warning",
        )

    return all_portfolios


@handle_errors(
    "{class_name} portfolio analysis",
    {{
        ValueError: {class_name}ExecutionError,
        KeyError: {class_name}ConfigurationError,
        ConfigurationError: {class_name}ConfigurationError,
        PortfolioLoadError: {class_name}PortfolioError,
        StrategyProcessingError: {class_name}ExecutionError,
        Exception: {class_name}Error,
    }},
)
def run(config: Config = DEFAULT_CONFIG) -> bool:
    """Run portfolio analysis for single or multiple tickers.

    This function handles the main workflow of portfolio analysis:
    1. Processes each ticker (single or multiple)
    2. Performs parameter sensitivity analysis
    3. Filters portfolios based on criteria
    4. Displays and saves results

    Args:
        config (Config): Configuration dictionary containing analysis parameters

    Returns:
        bool: True if execution successful, False otherwise

    Raises:
        {class_name}ConfigurationError: If the configuration is invalid
        {class_name}ExecutionError: If there's an error processing a strategy
        {class_name}PortfolioError: If the portfolio cannot be loaded
        ExportError: If results cannot be exported
        {class_name}Error: For other unexpected errors
    """
    with logging_context(
        module_name="{strategy_name}", log_file="1_get_portfolios.log"
    ) as log:
        # SAFEGUARD: Trade history export is not available for parameter sweep strategies
        # to prevent generating thousands of JSON files due to parameter combinations.
        # Trade history export is only available through app/concurrency/review.py
        config_copy = config.copy()
        if "EXPORT_TRADE_HISTORY" in config_copy:
            del config_copy["EXPORT_TRADE_HISTORY"]
        if config.get("EXPORT_TRADE_HISTORY", False):
            log(
                "WARNING: Trade history export is not supported for parameter sweep strategies. Use app/concurrency/review.py for trade history export.",
                "warning",
            )

        # Use the PortfolioOrchestrator for cleaner workflow management
        orchestrator = PortfolioOrchestrator(log)
        return orchestrator.run(config_copy)


@handle_errors(
    "{class_name} strategies analysis",
    {{
        ValueError: {class_name}ExecutionError,
        KeyError: {class_name}ConfigurationError,
        ConfigurationError: {class_name}ConfigurationError,
        PortfolioLoadError: {class_name}PortfolioError,
        StrategyProcessingError: {class_name}ExecutionError,
        Exception: {class_name}Error,
    }},
)
def run_strategies(config: Dict[str, Any] = None) -> bool:
    """Run analysis with strategies specified in STRATEGY_TYPES in sequence.

    Returns:
        bool: True if execution successful, False otherwise

    Raises:
        {class_name}ConfigurationError: If the configuration is invalid
        {class_name}ExecutionError: If there's an error processing a strategy
        {class_name}PortfolioError: If the portfolio cannot be loaded
        ExportError: If results cannot be exported
        {class_name}Error: For other unexpected errors
    """
    with logging_context(
        module_name="{strategy_name}", log_file="1_get_portfolios.log"
    ) as log:
        # Prepare config
        if config is not None and config:
            config_copy = config.copy()
        else:
            config_copy = DEFAULT_CONFIG.copy()

        # SAFEGUARD: Trade history export is not available for parameter sweep strategies
        # to prevent generating thousands of JSON files due to parameter combinations.
        # Trade history export is only available through app/concurrency/review.py
        if "EXPORT_TRADE_HISTORY" in config_copy:
            del config_copy["EXPORT_TRADE_HISTORY"]
        if config_copy.get("EXPORT_TRADE_HISTORY", False):
            log(
                "WARNING: Trade history export is not supported for parameter sweep strategies. Use app/concurrency/review.py for trade history export.",
                "warning",
            )

        # Use the PortfolioOrchestrator for cleaner workflow management
        orchestrator = PortfolioOrchestrator(log)
        return orchestrator.run(config_copy)


if __name__ == "__main__":
    run_from_command_line(
        run_strategies,
        {{}},  # Empty config as run_strategies uses the default DEFAULT_CONFIG
        "{class_name} portfolio analysis",
    )
'''

        return template

    def generate_strategy_execution_file(self) -> str:
        """Generate the strategy execution file template."""
        strategy_name = self.config.strategy_name
        class_name = strategy_name.replace("_", "").title()

        # Generate indicator calculation code based on strategy type
        indicator_code = self._generate_indicator_calculations()
        signal_code = self._generate_signal_logic()

        template = f'''"""
Strategy Execution Module for {class_name} Strategy

This module contains the core strategy execution logic for {strategy_name}.
It handles signal generation, portfolio construction, and performance metrics calculation.

Generated by Strategy Template Generator.
"""

from typing import Any, Dict, Optional, Callable
import polars as pl
import pandas as pd
import numpy as np

# Technical indicator imports
{chr(10).join(self.config.get_strategy_specific_imports())}

from app.tools.strategy.signal_processing import SignalProcessorFactory
from app.tools.strategy.export_portfolios import export_portfolios
from app.tools.strategy.filter_portfolios import filter_portfolios
from app.tools.data_processing import process_data_with_caching
from app.tools.exceptions import StrategyProcessingError


def calculate_indicators(data: pl.DataFrame, config: Dict[str, Any]) -> pl.DataFrame:
    """Calculate technical indicators for {strategy_name} strategy.

    Args:
        data: Price data DataFrame with OHLCV columns
        config: Strategy configuration

    Returns:
        DataFrame with added indicator columns
    """
    df = data.clone()

{indicator_code}

    return df


def generate_signals(data: pl.DataFrame, config: Dict[str, Any]) -> pl.DataFrame:
    """Generate trading signals for {strategy_name} strategy.

    Args:
        data: DataFrame with price data and indicators
        config: Strategy configuration

    Returns:
        DataFrame with signal columns added
    """
    df = data.clone()

{signal_code}

    return df


def execute_strategy(
    config: Dict[str, Any],
    strategy_type: str,
    log: Callable
) -> Optional[pl.DataFrame]:
    """Execute {strategy_name} strategy analysis.

    Args:
        config: Strategy configuration
        strategy_type: Type of strategy being executed
        log: Logging function

    Returns:
        Portfolio results DataFrame or None if no results

    Raises:
        StrategyProcessingError: If strategy execution fails
    """
    try:
        # Use centralized signal processing
        processor = SignalProcessorFactory.create_processor("{strategy_name.upper()}")

        # Process current signals if enabled
        if config.get("USE_CURRENT", False):
            current_signals = processor.process_current_signals(
                config.get("TICKER", "AAPL"), config, log
            )
            if current_signals is not None:
                log(f"Generated {{len(current_signals)}} current signals")

        # Process ticker portfolios
        portfolios_df = processor.process_ticker_portfolios(
            config.get("TICKER", "AAPL"), config, log
        )

        if portfolios_df is None or len(portfolios_df) == 0:
            log("No portfolios generated for strategy", "warning")
            return None

        log(f"Generated {{len(portfolios_df)}} portfolios")
        return portfolios_df

    except Exception as e:
        log(f"Strategy execution failed: {{str(e)}}", "error")
        raise StrategyProcessingError(f"{class_name} strategy execution failed") from e


def validate_strategy_config(config: Dict[str, Any]) -> bool:
    """Validate strategy-specific configuration.

    Args:
        config: Strategy configuration to validate

    Returns:
        True if configuration is valid

    Raises:
        ValueError: If configuration is invalid
    """
{self._generate_config_validation()}

    return True
'''

        return template

    def _generate_indicator_calculations(self) -> str:
        """Generate indicator calculation code based on strategy configuration."""
        lines = []
        indent = "    "

        if self.config.strategy_type == StrategyType.MOVING_AVERAGE:
            lines.extend(
                [
                    f"{indent}# Calculate moving averages",
                    f"{indent}fast_period = config.get('FAST_PERIOD', 20)",
                    f"{indent}slow_period = config.get('SLOW_PERIOD', 50)",
                    f"{indent}",
                    f"{indent}# Convert to pandas for indicator calculation",
                    f"{indent}pandas_df = df.to_pandas()",
                    f"{indent}",
                    f"{indent}# Calculate SMA",
                    f"{indent}sma_short = SMAIndicator(pandas_df['Close'], window=fast_period)",
                    f"{indent}sma_long = SMAIndicator(pandas_df['Close'], window=slow_period)",
                    f"{indent}",
                    f"{indent}# Calculate EMA",
                    f"{indent}ema_short = EMAIndicator(pandas_df['Close'], window=fast_period)",
                    f"{indent}ema_long = EMAIndicator(pandas_df['Close'], window=slow_period)",
                    f"{indent}",
                    f"{indent}# Add indicators back to polars DataFrame",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    pl.Series('SMA_Short', sma_short.sma_indicator()),",
                    f"{indent}    pl.Series('SMA_Long', sma_long.sma_indicator()),",
                    f"{indent}    pl.Series('EMA_Short', ema_short.ema_indicator()),",
                    f"{indent}    pl.Series('EMA_Long', ema_long.ema_indicator()),",
                    f"{indent}])",
                ]
            )

        elif self.config.strategy_type == StrategyType.RSI:
            lines.extend(
                [
                    f"{indent}# Calculate RSI",
                    f"{indent}rsi_period = config.get('RSI_PERIOD', 14)",
                    f"{indent}",
                    f"{indent}# Convert to pandas for indicator calculation",
                    f"{indent}pandas_df = df.to_pandas()",
                    f"{indent}",
                    f"{indent}rsi = RSIIndicator(pandas_df['Close'], window=rsi_period)",
                    f"{indent}",
                    f"{indent}# Add RSI back to polars DataFrame",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    pl.Series('RSI', rsi.rsi()),",
                    f"{indent}])",
                ]
            )

        elif self.config.strategy_type == StrategyType.MACD:
            lines.extend(
                [
                    f"{indent}# Calculate MACD",
                    f"{indent}fast_period = config.get('MACD_FAST', 12)",
                    f"{indent}slow_period = config.get('MACD_SLOW', 26)",
                    f"{indent}signal_period = config.get('MACD_SIGNAL', 9)",
                    f"{indent}",
                    f"{indent}# Convert to pandas for indicator calculation",
                    f"{indent}pandas_df = df.to_pandas()",
                    f"{indent}",
                    f"{indent}macd = MACD(pandas_df['Close'], window_fast=fast_period, window_slow=slow_period, window_sign=signal_period)",
                    f"{indent}",
                    f"{indent}# Add MACD indicators back to polars DataFrame",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    pl.Series('MACD_Line', macd.macd()),",
                    f"{indent}    pl.Series('MACD_Signal', macd.macd_signal()),",
                    f"{indent}    pl.Series('MACD_Histogram', macd.macd_diff()),",
                    f"{indent}])",
                ]
            )

        elif self.config.strategy_type == StrategyType.BOLLINGER_BANDS:
            lines.extend(
                [
                    f"{indent}# Calculate Bollinger Bands",
                    f"{indent}bb_period = config.get('BB_PERIOD', 20)",
                    f"{indent}bb_std = config.get('BB_STD_DEV', 2.0)",
                    f"{indent}",
                    f"{indent}# Convert to pandas for indicator calculation",
                    f"{indent}pandas_df = df.to_pandas()",
                    f"{indent}",
                    f"{indent}bb = BollingerBands(pandas_df['Close'], window=bb_period, window_dev=bb_std)",
                    f"{indent}",
                    f"{indent}# Add Bollinger Bands back to polars DataFrame",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    pl.Series('BB_Upper', bb.bollinger_hband()),",
                    f"{indent}    pl.Series('BB_Middle', bb.bollinger_mavg()),",
                    f"{indent}    pl.Series('BB_Lower', bb.bollinger_lband()),",
                    f"{indent}])",
                ]
            )

        else:  # CUSTOM or other types
            lines.extend(
                [
                    f"{indent}# Add custom indicator calculations here",
                    f"{indent}# Example: Custom momentum calculation",
                    f"{indent}momentum_period = config.get('MOMENTUM_PERIOD', 10)",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    (pl.col('Close') / pl.col('Close').shift(momentum_period) - 1).alias('Momentum'),",
                    f"{indent}])",
                ]
            )

        return "\n".join(lines)

    def _generate_signal_logic(self) -> str:
        """Generate signal logic code based on strategy configuration."""
        lines = []
        indent = "    "

        if self.config.strategy_type == StrategyType.MOVING_AVERAGE:
            lines.extend(
                [
                    f"{indent}# Generate moving average crossover signals",
                    f"{indent}strategy_type = config.get('STRATEGY_TYPE', 'SMA')",
                    f"{indent}direction = config.get('DIRECTION', 'Long')",
                    f"{indent}",
                    f"{indent}if strategy_type == 'SMA':",
                    f"{indent}    # SMA crossover signals",
                    f"{indent}    if direction == 'Long':",
                    f"{indent}        entry_signal = (pl.col('SMA_Short') > pl.col('SMA_Long')) & (pl.col('SMA_Short').shift(1) <= pl.col('SMA_Long').shift(1))",
                    f"{indent}        exit_signal = (pl.col('SMA_Short') < pl.col('SMA_Long')) & (pl.col('SMA_Short').shift(1) >= pl.col('SMA_Long').shift(1))",
                    f"{indent}    else:  # Short",
                    f"{indent}        entry_signal = (pl.col('SMA_Short') < pl.col('SMA_Long')) & (pl.col('SMA_Short').shift(1) >= pl.col('SMA_Long').shift(1))",
                    f"{indent}        exit_signal = (pl.col('SMA_Short') > pl.col('SMA_Long')) & (pl.col('SMA_Short').shift(1) <= pl.col('SMA_Long').shift(1))",
                    f"{indent}elif strategy_type == 'EMA':",
                    f"{indent}    # EMA crossover signals",
                    f"{indent}    if direction == 'Long':",
                    f"{indent}        entry_signal = (pl.col('EMA_Short') > pl.col('EMA_Long')) & (pl.col('EMA_Short').shift(1) <= pl.col('EMA_Long').shift(1))",
                    f"{indent}        exit_signal = (pl.col('EMA_Short') < pl.col('EMA_Long')) & (pl.col('EMA_Short').shift(1) >= pl.col('EMA_Long').shift(1))",
                    f"{indent}    else:  # Short",
                    f"{indent}        entry_signal = (pl.col('EMA_Short') < pl.col('EMA_Long')) & (pl.col('EMA_Short').shift(1) >= pl.col('EMA_Long').shift(1))",
                    f"{indent}        exit_signal = (pl.col('EMA_Short') > pl.col('EMA_Long')) & (pl.col('EMA_Short').shift(1) <= pl.col('EMA_Long').shift(1))",
                    f"{indent}",
                    f"{indent}# Add signal columns",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    entry_signal.alias('Entry_Signal'),",
                    f"{indent}    exit_signal.alias('Exit_Signal'),",
                    f"{indent}])",
                ]
            )

        elif self.config.strategy_type == StrategyType.RSI:
            lines.extend(
                [
                    f"{indent}# Generate RSI signals",
                    f"{indent}rsi_overbought = config.get('RSI_OVERBOUGHT', 70)",
                    f"{indent}rsi_oversold = config.get('RSI_OVERSOLD', 30)",
                    f"{indent}direction = config.get('DIRECTION', 'Long')",
                    f"{indent}",
                    f"{indent}if direction == 'Long':",
                    f"{indent}    # Buy when RSI crosses above oversold, sell when crosses below overbought",
                    f"{indent}    entry_signal = (pl.col('RSI') > rsi_oversold) & (pl.col('RSI').shift(1) <= rsi_oversold)",
                    f"{indent}    exit_signal = (pl.col('RSI') < rsi_overbought) & (pl.col('RSI').shift(1) >= rsi_overbought)",
                    f"{indent}else:  # Short",
                    f"{indent}    # Sell when RSI crosses below overbought, cover when crosses above oversold",
                    f"{indent}    entry_signal = (pl.col('RSI') < rsi_overbought) & (pl.col('RSI').shift(1) >= rsi_overbought)",
                    f"{indent}    exit_signal = (pl.col('RSI') > rsi_oversold) & (pl.col('RSI').shift(1) <= rsi_oversold)",
                    f"{indent}",
                    f"{indent}# Add signal columns",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    entry_signal.alias('Entry_Signal'),",
                    f"{indent}    exit_signal.alias('Exit_Signal'),",
                    f"{indent}])",
                ]
            )

        else:  # Default/Custom signal logic
            lines.extend(
                [
                    f"{indent}# Generate custom signals",
                    f"{indent}# Add your custom signal logic here",
                    f"{indent}direction = config.get('DIRECTION', 'Long')",
                    f"{indent}",
                    f"{indent}# Example: Simple momentum-based signals",
                    f"{indent}momentum_threshold = config.get('MOMENTUM_THRESHOLD', 0.02)",
                    f"{indent}",
                    f"{indent}if direction == 'Long':",
                    f"{indent}    entry_signal = pl.col('Momentum') > momentum_threshold",
                    f"{indent}    exit_signal = pl.col('Momentum') < -momentum_threshold",
                    f"{indent}else:  # Short",
                    f"{indent}    entry_signal = pl.col('Momentum') < -momentum_threshold",
                    f"{indent}    exit_signal = pl.col('Momentum') > momentum_threshold",
                    f"{indent}",
                    f"{indent}# Add signal columns",
                    f"{indent}df = df.with_columns([",
                    f"{indent}    entry_signal.alias('Entry_Signal'),",
                    f"{indent}    exit_signal.alias('Exit_Signal'),",
                    f"{indent}])",
                ]
            )

        return "\n".join(lines)

    def _generate_config_validation(self) -> str:
        """Generate configuration validation code."""
        lines = []
        indent = "    "

        # Basic validation
        lines.extend(
            [
                f"{indent}# Basic validation",
                f"{indent}if not config.get('TICKER'):",
                f"{indent}    raise ValueError('TICKER is required')",
                f"{indent}",
                f"{indent}if config.get('DIRECTION') not in ['Long', 'Short']:",
                f"{indent}    raise ValueError('DIRECTION must be Long or Short')",
            ]
        )

        # Strategy-specific validation
        if self.config.strategy_type == StrategyType.MOVING_AVERAGE:
            lines.extend(
                [
                    f"{indent}",
                    f"{indent}# Moving average specific validation",
                    f"{indent}fast_period = config.get('FAST_PERIOD', 20)",
                    f"{indent}slow_period = config.get('SLOW_PERIOD', 50)",
                    f"{indent}",
                    f"{indent}if fast_period <= 0 or slow_period <= 0:",
                    f"{indent}    raise ValueError('Window sizes must be positive')",
                    f"{indent}",
                    f"{indent}if fast_period >= slow_period:",
                    f"{indent}    raise ValueError('Fast period must be less than slow period')",
                ]
            )

        elif self.config.strategy_type == StrategyType.RSI:
            lines.extend(
                [
                    f"{indent}",
                    f"{indent}# RSI specific validation",
                    f"{indent}rsi_period = config.get('RSI_PERIOD', 14)",
                    f"{indent}rsi_overbought = config.get('RSI_OVERBOUGHT', 70)",
                    f"{indent}rsi_oversold = config.get('RSI_OVERSOLD', 30)",
                    f"{indent}",
                    f"{indent}if rsi_period <= 0:",
                    f"{indent}    raise ValueError('RSI period must be positive')",
                    f"{indent}",
                    f"{indent}if not (0 < rsi_oversold < rsi_overbought < 100):",
                    f"{indent}    raise ValueError('Invalid RSI thresholds')",
                ]
            )

        return "\n".join(lines)

    def generate_exceptions_file(self) -> str:
        """Generate strategy-specific exceptions file."""
        strategy_name = self.config.strategy_name
        class_name = strategy_name.replace("_", "").title()

        template = f'''"""
Exception classes for {class_name} Strategy

Generated by Strategy Template Generator.
"""

from app.tools.strategy.error_handling import StrategyError, StrategyErrorCode, ErrorSeverity


class {class_name}Error(StrategyError):
    """Base exception for {strategy_name} strategy."""

    def __init__(self, message: str, context: dict = None):
        super().__init__(
            message=message,
            error_code=StrategyErrorCode.STRATEGY_EXECUTION_ERROR,
            severity=ErrorSeverity.ERROR,
            context=context
        )


class {class_name}ConfigurationError({class_name}Error):
    """Exception raised for configuration errors in {strategy_name} strategy."""

    def __init__(self, message: str, context: dict = None):
        super().__init__(
            message=f"Configuration error: {{message}}",
            context=context
        )
        self.error_code = StrategyErrorCode.CONFIGURATION_ERROR


class {class_name}ExecutionError({class_name}Error):
    """Exception raised for execution errors in {strategy_name} strategy."""

    def __init__(self, message: str, context: dict = None):
        super().__init__(
            message=f"Execution error: {{message}}",
            context=context
        )
        self.error_code = StrategyErrorCode.STRATEGY_EXECUTION_ERROR


class {class_name}PortfolioError({class_name}Error):
    """Exception raised for portfolio-related errors in {strategy_name} strategy."""

    def __init__(self, message: str, context: dict = None):
        super().__init__(
            message=f"Portfolio error: {{message}}",
            context=context
        )
        self.error_code = StrategyErrorCode.PORTFOLIO_ERROR
'''

        return template
