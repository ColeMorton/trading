"""Unit tests for concurrency analysis components."""

import unittest
from unittest.mock import Mock, patch, MagicMock
import numpy as np
import pandas as pd
from datetime import datetime, timedelta

from app.concurrency.tools.analysis import (
    analyze_concurrency,
    calculate_concurrency_metrics,
    align_strategy_data,
)
from app.concurrency.tools.data_alignment import (
    align_signals,
    create_alignment_index,
    interpolate_signals,
)
from app.concurrency.tools.signal_metrics import (
    calculate_signal_metrics,
    calculate_signal_quality,
    calculate_signal_overlap,
)
from app.concurrency.tools.efficiency import (
    calculate_efficiency_metrics,
    calculate_diversification,
    calculate_independence,
)
from base import ConcurrencyTestCase, MockDataMixin


class TestDataAlignment(ConcurrencyTestCase, MockDataMixin):
    """Test data alignment functions."""

    def test_create_alignment_index(self):
        """Test creation of alignment index from multiple series."""
        # Create test data with different date ranges
        dates1 = pd.date_range('2023-01-01', periods=10)
        dates2 = pd.date_range('2023-01-05', periods=10)

        data = [
            {"dates": dates1, "ticker": "BTC"},
            {"dates": dates2, "ticker": "ETH"},
        ]

        index = create_alignment_index(data)

        # Should cover full range
        self.assertEqual(len(index), 14)  # Jan 1-14
        self.assertEqual(index[0], dates1[0])
        self.assertEqual(index[-1], dates2[-1])

    def test_align_signals_simple(self):
        """Test basic signal alignment."""
        # Create test signals
        dates1 = pd.date_range('2023-01-01', periods=5)
        dates2 = pd.date_range('2023-01-02', periods=5)

        signals1 = pd.Series([1, 0, 1, 0, 1], index=dates1)
        signals2 = pd.Series([0, 1, 1, 0, 0], index=dates2)

        # Create common index
        common_index = pd.date_range('2023-01-01', periods=6)

        aligned = align_signals([signals1, signals2], common_index)

        self.assertEqual(len(aligned), 2)
        self.assertEqual(len(aligned[0]), 6)
        self.assertEqual(len(aligned[1]), 6)

        # Check alignment
        self.assertEqual(aligned[0].iloc[0], 1)  # From signals1
        self.assertTrue(pd.isna(aligned[1].iloc[0]))  # No data for signals2 on Jan 1

    def test_interpolate_signals(self):
        """Test signal interpolation for missing data."""
        # Create signals with gaps
        dates = pd.date_range('2023-01-01', periods=5)
        signals = pd.Series([1, np.nan, np.nan, 0, 1], index=dates)

        # Forward fill
        filled = interpolate_signals(signals, method='ffill')
        self.assertEqual(filled.iloc[1], 1)  # Filled from previous
        self.assertEqual(filled.iloc[2], 1)  # Filled from previous

        # Zero fill
        zero_filled = interpolate_signals(signals, method='zero')
        self.assertEqual(zero_filled.iloc[1], 0)
        self.assertEqual(zero_filled.iloc[2], 0)


class TestSignalMetrics(ConcurrencyTestCase, MockDataMixin):
    """Test signal metrics calculation."""

    def test_calculate_signal_overlap(self):
        """Test overlap calculation between signals."""
        # Create test signals
        signals1 = pd.Series([1, 1, 0, 0, 1, 1, 0, 0])
        signals2 = pd.Series([0, 1, 1, 0, 0, 1, 1, 0])

        overlap = calculate_signal_overlap(signals1, signals2)

        # Overlap occurs at indices 1 and 5
        expected_overlap = 2 / 8  # 2 overlapping periods out of 8
        self.assertAlmostEqual(overlap, expected_overlap)

    def test_calculate_signal_quality(self):
        """Test signal quality metrics calculation."""
        # Create signals with returns
        signals = pd.Series([1, 1, 0, 0, 1, 1, 0, 0])
        returns = pd.Series([0.02, 0.01, -0.01, 0.00, 0.03, -0.02, 0.01, 0.00])

        quality = calculate_signal_quality(signals, returns)

        # Check quality metrics
        self.assertIn('hit_rate', quality)
        self.assertIn('avg_return', quality)
        self.assertIn('signal_ratio', quality)

        # Signal ratio should be 4/8 = 0.5
        self.assertEqual(quality['signal_ratio'], 0.5)

        # Hit rate: 3 positive returns out of 4 signals
        self.assertEqual(quality['hit_rate'], 0.75)

    def test_calculate_signal_metrics_comprehensive(self):
        """Test comprehensive signal metrics calculation."""
        # Create mock strategy data
        strategy_data = []

        for i in range(3):
            signals = self.create_mock_signals(100, signal_rate=0.3 + i * 0.1)
            returns = np.random.normal(0.001, 0.02, 100)

            strategy_data.append({
                'ticker': f'TEST{i}',
                'signals': pd.Series(signals),
                'returns': pd.Series(returns),
                'dates': pd.date_range('2023-01-01', periods=100),
            })

        metrics = calculate_signal_metrics(strategy_data, self.log_mock)

        # Check structure
        self.assertIn('signal_counts', metrics)
        self.assertIn('overlap_matrix', metrics)
        self.assertIn('quality_scores', metrics)

        # Check overlap matrix shape
        self.assertEqual(len(metrics['overlap_matrix']), 3)
        self.assertEqual(len(metrics['overlap_matrix'][0]), 3)


class TestEfficiencyMetrics(ConcurrencyTestCase, MockDataMixin):
    """Test efficiency metrics calculation."""

    def test_calculate_diversification(self):
        """Test diversification calculation."""
        # Create correlation matrix
        # High correlation = low diversification
        corr_matrix = np.array([
            [1.0, 0.9, 0.8],
            [0.9, 1.0, 0.85],
            [0.8, 0.85, 1.0]
        ])

        diversification = calculate_diversification(corr_matrix)

        # Should be less than 1 due to high correlations
        self.assertLess(diversification, 1.0)
        self.assertGreater(diversification, 0.0)

        # Test with low correlation
        low_corr_matrix = np.array([
            [1.0, 0.1, 0.05],
            [0.1, 1.0, 0.15],
            [0.05, 0.15, 1.0]
        ])

        high_diversification = calculate_diversification(low_corr_matrix)

        # Should be higher than previous
        self.assertGreater(high_diversification, diversification)

    def test_calculate_independence(self):
        """Test independence calculation."""
        # Create overlap data
        # High overlap = low independence
        overlap_matrix = np.array([
            [1.0, 0.8, 0.7],
            [0.8, 1.0, 0.75],
            [0.7, 0.75, 1.0]
        ])

        independence = calculate_independence(overlap_matrix)

        # Should be less than 1 due to high overlaps
        self.assertLess(independence, 1.0)
        self.assertGreater(independence, 0.0)

    def test_calculate_efficiency_metrics(self):
        """Test comprehensive efficiency metrics calculation."""
        # Create mock data
        stats = {
            'correlation_matrix': np.array([
                [1.0, 0.3, 0.2],
                [0.3, 1.0, 0.25],
                [0.2, 0.25, 1.0]
            ]),
            'overlap_matrix': np.array([
                [1.0, 0.2, 0.15],
                [0.2, 1.0, 0.18],
                [0.15, 0.18, 1.0]
            ]),
            'signal_activity': [0.3, 0.4, 0.35],
            'performance_metrics': {
                'strategy_returns': [0.15, 0.20, 0.18],
                'strategy_sharpe': [1.2, 1.5, 1.3],
            }
        }

        efficiency = calculate_efficiency_metrics(stats, self.log_mock)

        # Check all components are present
        self.assertIn('diversification_multiplier', efficiency)
        self.assertIn('independence_multiplier', efficiency)
        self.assertIn('activity_multiplier', efficiency)
        self.assertIn('efficiency_score', efficiency)

        # All multipliers should be positive
        self.assertGreater(efficiency['diversification_multiplier'], 0)
        self.assertGreater(efficiency['independence_multiplier'], 0)
        self.assertGreater(efficiency['activity_multiplier'], 0)
        self.assertGreater(efficiency['efficiency_score'], 0)


class TestConcurrencyAnalysis(ConcurrencyTestCase, MockDataMixin):
    """Test main concurrency analysis function."""

    @patch('app.concurrency.tools.analysis.align_strategy_data')
    @patch('app.concurrency.tools.analysis.calculate_concurrency_metrics')
    def test_analyze_concurrency_basic(self, mock_metrics, mock_align):
        """Test basic concurrency analysis flow."""
        # Setup mocks
        mock_aligned_data = [
            {
                'ticker': 'BTC',
                'signals': pd.Series([1, 0, 1]),
                'dates': pd.date_range('2023-01-01', periods=3),
            }
        ]
        mock_align.return_value = mock_aligned_data

        mock_stats = {
            'total_concurrent_periods': 2,
            'concurrency_ratio': 0.67,
            'efficiency_score': 0.85,
        }
        mock_metrics.return_value = mock_stats

        # Create test data
        strategy_data = [self.create_mock_portfolio_data(1)[0]]
        strategies = [{'ticker': 'BTC'}]

        # Run analysis
        stats, aligned = analyze_concurrency(
            strategy_data,
            strategies,
            self.log_mock
        )

        # Verify results
        self.assertEqual(stats, mock_stats)
        self.assertEqual(aligned, mock_aligned_data)

        # Verify calls
        mock_align.assert_called_once()
        mock_metrics.assert_called_once()

    def test_calculate_concurrency_metrics_comprehensive(self):
        """Test comprehensive concurrency metrics calculation."""
        # Create aligned data with known patterns
        dates = pd.date_range('2023-01-01', periods=10)

        aligned_data = [
            {
                'ticker': 'BTC',
                'signals': pd.Series([1, 1, 0, 0, 1, 1, 0, 0, 1, 1], index=dates),
                'returns': pd.Series(np.random.normal(0.001, 0.02, 10), index=dates),
            },
            {
                'ticker': 'ETH',
                'signals': pd.Series([0, 1, 1, 0, 0, 1, 1, 0, 0, 1], index=dates),
                'returns': pd.Series(np.random.normal(0.001, 0.02, 10), index=dates),
            },
            {
                'ticker': 'SOL',
                'signals': pd.Series([1, 0, 1, 1, 0, 0, 1, 1, 0, 0], index=dates),
                'returns': pd.Series(np.random.normal(0.001, 0.02, 10), index=dates),
            },
        ]

        strategies = [
            {'ticker': 'BTC', 'allocation': 40},
            {'ticker': 'ETH', 'allocation': 35},
            {'ticker': 'SOL', 'allocation': 25},
        ]

        metrics = calculate_concurrency_metrics(
            aligned_data,
            strategies,
            self.log_mock
        )

        # Check all expected metrics
        expected_metrics = [
            'total_concurrent_periods',
            'concurrency_ratio',
            'exclusive_ratio',
            'inactive_ratio',
            'avg_concurrent_strategies',
            'max_concurrent_strategies',
            'concurrent_periods_by_count',
            'correlation_matrix',
            'overlap_matrix',
            'efficiency_score',
            'risk_concentration_index',
        ]

        for metric in expected_metrics:
            self.assertIn(metric, metrics, f"Missing metric: {metric}")

        # Validate metric ranges
        self.assertGreaterEqual(metrics['concurrency_ratio'], 0)
        self.assertLessEqual(metrics['concurrency_ratio'], 1)
        self.assertGreaterEqual(metrics['exclusive_ratio'], 0)
        self.assertLessEqual(metrics['exclusive_ratio'], 1)
        self.assertGreaterEqual(metrics['inactive_ratio'], 0)
        self.assertLessEqual(metrics['inactive_ratio'], 1)

        # Sum of ratios should be 1
        ratio_sum = (
            metrics['concurrency_ratio'] +
            metrics['exclusive_ratio'] +
            metrics['inactive_ratio']
        )
        self.assertAlmostEqual(ratio_sum, 1.0, places=5)


if __name__ == "__main__":
    unittest.main()
