"""Unit tests for concurrency analysis components - cleaned version.

Only tests functions that are actually implemented.
"""

import unittest
from unittest.mock import Mock, patch, MagicMock
import numpy as np
import pandas as pd
from datetime import datetime, timedelta

from app.concurrency.tools.analysis import analyze_concurrency
from app.concurrency.tools.data_alignment import (
    resample_hourly_to_daily,
    prepare_dataframe,
    find_common_dates,
    align_data,
    align_multiple_data,
)
from app.concurrency.tools.signal_metrics import calculate_signal_metrics
from app.concurrency.tools.efficiency import (
    calculate_strategy_efficiency,
    calculate_portfolio_efficiency,
    calculate_independence_factor,
    calculate_risk_factor,
    normalize_values,
)
from base import ConcurrencyTestCase, MockDataMixin


class TestDataAlignment(ConcurrencyTestCase, MockDataMixin):
    """Test data alignment functions."""
    
    def test_resample_hourly_to_daily(self):
        """Test resampling hourly data to daily."""
        # Create hourly data
        hourly_dates = pd.date_range('2023-01-01', periods=48, freq='H')
        hourly_data = pd.DataFrame({
            'open': np.random.randn(48) + 100,
            'high': np.random.randn(48) + 101,
            'low': np.random.randn(48) + 99,
            'close': np.random.randn(48) + 100,
            'signals': [1, 0] * 24  # Alternating signals
        }, index=hourly_dates)
        
        # Resample to daily
        daily_data = resample_hourly_to_daily(hourly_data)
        
        # Check results
        self.assertEqual(len(daily_data), 2)  # 48 hours = 2 days
        self.assertIn('signals', daily_data.columns)
        
        # Check signal aggregation (should use last value of day)
        self.assertIn(daily_data['signals'].iloc[0], [0, 1])
    
    def test_find_common_dates(self):
        """Test finding common dates across multiple series."""
        # Create test data with overlapping dates
        dates1 = pd.date_range('2023-01-01', periods=10)
        dates2 = pd.date_range('2023-01-05', periods=10)
        dates3 = pd.date_range('2023-01-03', periods=8)
        
        data_list = [
            pd.DataFrame({'value': range(10)}, index=dates1),
            pd.DataFrame({'value': range(10)}, index=dates2),
            pd.DataFrame({'value': range(8)}, index=dates3),
        ]
        
        common_dates = find_common_dates(data_list)
        
        # Should only include dates present in all series
        # Common range is Jan 5-10 (6 days)
        self.assertEqual(len(common_dates), 6)
        self.assertEqual(common_dates[0], pd.Timestamp('2023-01-05'))
        self.assertEqual(common_dates[-1], pd.Timestamp('2023-01-10'))
    
    def test_align_data(self):
        """Test aligning data to common dates."""
        # Create test data
        dates1 = pd.date_range('2023-01-01', periods=10)
        dates2 = pd.date_range('2023-01-05', periods=10)
        
        df1 = pd.DataFrame({'signals': range(10)}, index=dates1)
        df2 = pd.DataFrame({'signals': range(10, 20)}, index=dates2)
        
        # Align data
        aligned = align_data([df1, df2])
        
        # Check alignment
        self.assertEqual(len(aligned), 2)
        self.assertTrue(all(len(df) == 6 for df in aligned))  # Common period
        
        # Check index alignment
        for df in aligned:
            self.assertEqual(df.index[0], pd.Timestamp('2023-01-05'))


class TestSignalMetrics(ConcurrencyTestCase, MockDataMixin):
    """Test signal metrics calculation."""
    
    def test_calculate_signal_metrics_basic(self):
        """Test basic signal metrics calculation."""
        # Create mock strategy data
        strategies = [
            {'ticker': 'BTC', 'signals': pd.Series([1, 0, 1, 0, 1])},
            {'ticker': 'ETH', 'signals': pd.Series([0, 1, 1, 0, 0])},
        ]
        
        # Calculate metrics
        result = calculate_signal_metrics(strategies, self.log_mock)
        
        # Check result type
        self.assertIsInstance(result, dict)
        
        # The actual structure depends on implementation
        # Just verify it returns without error
        self.assertIsNotNone(result)


class TestEfficiencyMetrics(ConcurrencyTestCase, MockDataMixin):
    """Test efficiency metrics calculation."""
    
    def test_calculate_independence_factor(self):
        """Test independence factor calculation."""
        # Test with different ratios
        factor = calculate_independence_factor(
            exclusive_ratio=0.4,
            concurrent_ratio=0.3,
            inactive_ratio=0.3
        )
        
        # Independence factor should be between 0 and 1
        self.assertGreaterEqual(factor, 0)
        self.assertLessEqual(factor, 1)
        
        # Higher exclusive ratio should give higher independence
        factor_high_exclusive = calculate_independence_factor(0.8, 0.1, 0.1)
        factor_low_exclusive = calculate_independence_factor(0.2, 0.7, 0.1)
        self.assertGreater(factor_high_exclusive, factor_low_exclusive)
    
    def test_calculate_risk_factor(self):
        """Test risk factor calculation."""
        # Low risk should give high factor
        factor_low_risk = calculate_risk_factor(0.1)
        self.assertGreater(factor_low_risk, 0.5)
        
        # High risk should give low factor
        factor_high_risk = calculate_risk_factor(0.9)
        self.assertLess(factor_high_risk, 0.5)
        
        # Factor should be between 0 and 1
        for risk in [0.0, 0.25, 0.5, 0.75, 1.0]:
            factor = calculate_risk_factor(risk)
            self.assertGreaterEqual(factor, 0)
            self.assertLessEqual(factor, 1)
    
    def test_normalize_values(self):
        """Test value normalization."""
        # Test with positive values
        values = [10, 20, 30, 40, 50]
        normalized = normalize_values(values)
        
        # Sum should be 1
        self.assertAlmostEqual(sum(normalized), 1.0)
        
        # Proportions should be maintained
        self.assertAlmostEqual(normalized[0] / normalized[1], 0.5)
        
        # Test with all zeros
        zeros = [0, 0, 0]
        normalized_zeros = normalize_values(zeros)
        # Should handle gracefully (equal distribution)
        self.assertEqual(len(normalized_zeros), 3)
        self.assertAlmostEqual(sum(normalized_zeros), 1.0)
    
    def test_calculate_strategy_efficiency(self):
        """Test strategy efficiency calculation."""
        # Mock strategy data
        strategy = {
            'expectancy': 0.02,
            'allocation': 0.25,
            'base_efficiency': 0.8,
            'risk_contribution': 0.2
        }
        
        efficiency = calculate_strategy_efficiency(strategy)
        
        # Should return a positive number
        self.assertGreater(efficiency, 0)
        
        # Test with missing fields (should handle gracefully)
        incomplete_strategy = {'expectancy': 0.01}
        efficiency_incomplete = calculate_strategy_efficiency(incomplete_strategy)
        self.assertGreaterEqual(efficiency_incomplete, 0)


class TestConcurrencyAnalysis(ConcurrencyTestCase, MockDataMixin):
    """Test main concurrency analysis function."""
    
    @patch('app.concurrency.tools.analysis.compile_statistics')
    def test_analyze_concurrency_basic(self, mock_compile):
        """Test basic concurrency analysis flow."""
        # Setup mock
        mock_stats = {
            'total_concurrent_periods': 10,
            'concurrency_ratio': 0.5,
            'efficiency_score': 0.85,
        }
        mock_compile.return_value = mock_stats
        
        # Create test strategies
        strategies = [
            {'ticker': 'BTC', 'allocation': 50},
            {'ticker': 'ETH', 'allocation': 50},
        ]
        
        # Run analysis
        result = analyze_concurrency(strategies, self.log_mock)
        
        # Verify result
        self.assertIsNotNone(result)
        self.assertEqual(result, mock_stats)
        
        # Verify compile_statistics was called
        mock_compile.assert_called_once()


if __name__ == "__main__":
    unittest.main()